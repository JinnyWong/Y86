# Notes on Y86 Emulator

## 01 How does it work?

A Y86 emulator simulates the behavior of a Y86 processor by executing Y86 instructions on a computer or other device. The emulator reads the instructions from a file or other source, decodes the instructions, and then simulates the operations performed by the instruction on the Y86 registers and memory.

The emulator uses code to simulate the behavior of the Y86 registers and memory, allowing it to mimic the execution of Y86 instructions. This allows the emulator to run Y86 programs as if they were being executed on a real Y86 processor.

As the instructions are executed, the emulator updates the state of the Y86 registers and memory, and outputs the results of the instructions to the user. This allows the user to see the effects of the instructions on the Y86 processor, and to debug and troubleshoot any issues with the program.

Overall, a Y86 emulator allows users to run Y86 programs on a computer or other device, without the need for a physical Y86 processor. This makes it a useful tool for developers and researchers working with the Y86 architecture.

.

## 02 How to build?

- Familiarize with Y86 instruction set and architecture.

- Create a program that can read and parse the Y86 instruction set. This will involve writing code to identify and decode each instruction, as well as the operands and registers used by the instruction.

- Implement the various Y86 registers, such as the EIP (Instruction Pointer), EFL (EFLAGS), and CC (Condition Codes). These registers are used to store information about the current instruction and state of the processor.

- Write code to simulate the Y86 memory and memory access. This will allow your emulator to read and write to memory locations as instructed by the Y86 instructions.

- Develop the code to simulate the execution of each Y86 instruction. This will involve writing code to simulate the operations performed by the instruction, such as arithmetic, logical, and control flow operations.

- Test your emulator by running it on a variety of Y86 programs and comparing the output with the expected results. This will help you identify any errors or bugs in your code and fix them.

- Continue to refine and optimize your emulator, adding features and functionality as needed. This may involve improving the performance of the emulator, adding support for additional instructions, or implementing advanced features such as debugging capabilities.

.

## 03 File structure of Y86 emulator

- `main.cpp`: This file contains the main entry point of the program, which is responsible for parsing the command-line arguments, loading the Y86 code to be executed, and setting up the emulator's memory and registers.

- y86_program.txt: A text file containing the Y86 program to be executed by the emulator.

- y86_input.txt: A text file containing any input data required by the Y86 program.

- y86_output.txt: A text file containing the output generated by the Y86 program.

- `emulator.h`: This file contains the declaration of the `Emulator` class, which represents the Y86 emulator itself. This class is likely to have methods for executing instructions, managing memory, and managing registers.

- `emulator.cpp`: This file contains the implementation of the `Emulator` class.

- `instructions.h`: This file contains declarations for the various classes that represent Y86 instructions, such as `Instruction`, `AddInstruction`, `SubInstruction`, etc. Each of these classes may have its own implementation for how to execute the instruction.

- `instructions.cpp`: This file contains the implementations for the instruction classes declared in `instructions.h`.

- `memory.h`: This file contains the declaration of the `Memory` class, which represents the emulator's memory. It may have methods for reading and writing memory, as well as for allocating and deallocating memory.

- `memory.cpp`: This file contains the implementation of the `Memory` class.

- `registers.h`: This file contains the declaration of the `Registers` class, which represents the emulator's registers. It may have methods for reading and writing registers, as well as for resetting the registers to their initial state.

- `registers.cpp`: This file contains the implementation of the `Registers` class.`main.cpp`: This file contains the main entry point of the program, which is responsible for parsing the command-line arguments, loading the Y86 code to be executed, and setting up the emulator's memory and registers.

- `emulator.h`: This file contains the declaration of the `Emulator` class, which represents the Y86 emulator itself. This class is likely to have methods for executing instructions, managing memory, and managing registers.

- `emulator.cpp`: This file contains the implementation of the `Emulator` class.

- `instructions.h`: This file contains declarations for the various classes that represent Y86 instructions, such as `Instruction`, `AddInstruction`, `SubInstruction`, etc. Each of these classes may have its own implementation for how to execute the instruction.

- `instructions.cpp`: This file contains the implementations for the instruction classes declared in `instructions.h`.

- `memory.h`: This file contains the declaration of the `Memory` class, which represents the emulator's memory. It may have methods for reading and writing memory, as well as for allocating and deallocating memory.

- `memory.cpp`: This file contains the implementation of the `Memory` class.

- `registers.h`: This file contains the declaration of the `Registers` class, which represents the emulator's registers. It may have methods for reading and writing registers, as well as for resetting the registers to their initial state.

- `registers.cpp`: This file contains the implementation of the `Registers` class.

------

#### Y86 Instruction Set

- mov: move data from one location to another
- add: add two numbers together
- sub: subtract one number from another
- jmp: jump to a specified memory location
- cmov: move data based on a condition code
- call: call a subroutine
- ret: return from a subroutine
- push: push a value onto the stack
- pop: pop a value off the stack
- and: perform a bitwise and operation on two numbers
- or: perform a bitwise or operation on two numbers
- instructions for accessing and manipulating memory, such as load and store instructions for reading and writing data to memory
- instructions for allocating and freeing memory.
